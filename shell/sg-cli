#!/bin/sh

# Define variables
readonly base_url="${SG_BASE_URL:-"https://api.app.stackguardian.io"}"
readonly api_url="$base_url/api/v1"
readonly dashboard_url="${SG_DASHBOARD_URL:-"https://app.stackguardian.io/orchestrator"}"
readonly api_token="$SG_API_TOKEN"

if ! type jq >/dev/null 2>&1; then
  echo
  echo "ERROR: jq command is required!"
  exit 2
fi

help() {
  cat <<EOF

  ./$(basename "$0") RESOURCE OPTION --org <ORG_NAME>

  RESOURCES:
    stack               manage stack resources
    workflow            manage workflow resources
    artifacts           manage artifacts
    aws                 manage aws integration

EOF
}

aws_help() {
  cat <<EOF

  ./$(basename "$0") aws OPTION --org <ORG_NAME>

  OPTIONS:
    integrate            integrate aws with Stackguardian

EOF
}

aws_integrate_help() {
  cat <<EOF

  ./$(basename "$0") aws integrate --org <ORG_NAME>

EOF
}

artifacts_help() {
  cat <<EOF

  ./$(basename "$0") artifacts OPTION --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> --workflow-id <WORKFLOW_ID>

  OPTIONS:
    list_all            list all artifacts

EOF
}

artifacts_list_all_help() {
  cat <<EOF

  ./$(basename "$0") artifacts list_all --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> --workflow-id <WORKFLOW_ID>

EOF
}

workflow_help() {
  cat <<EOF

  ./$(basename "$0") workflow OPTION --org <ORG_NAME> --workflow-group <WF_GROUP_NAME>

  OPTIONS:
    create              create new workflow
    list_all            list all workflows
    read                read workflow
    delete              delete workflow

EOF
}

stack_help() {
  cat <<EOF

  ./$(basename "$0") stack OPTION --org <ORG_NAME> --workflow-group <WF_GROUP_NAME>

  OPTIONS:
    create              create new stack
    delete              delete stack

EOF
}

stack_delete_help() {
  cat <<EOF

  ./$(basename "$0") stack delete --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> --stack-id <STACK_ID>

EOF
}

stack_create_help() {
  cat <<EOF

  ./$(basename "$0") stack create --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> OPTIONS -- <JSON_PAYLOAD_PATH>

  OPTIONS:
    --wait              wait for stack creation, applicable only when --run is set
    --run               run stack after creation
    --preview           preview payload before applying
    --dry-run           preview payload before applying (but do not create)
    --stack-id        set stack name, can not be used with --patch-payload
    --patch-payload     patch original json payload
    --output-json       outputs the response as json

EOF
}

workflow_delete_help() {
  cat <<EOF

  ./$(basename "$0") workflow delete --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> --workflow-id <WORKFLOW_ID>

EOF
}

workflow_create_help() {
  cat <<EOF

  ./$(basename "$0") workflow create --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> OPTIONS -- <JSON_PAYLOAD_PATH>

  OPTIONS:
    --preview           preview payload before applying
    --dry-run           preview payload before applying (but do not create)
    --workflow-id       set workflow name, can not be used with --patch-payload
    --patch-payload     patch original json payload
    --output-json       outputs the response as json

EOF
}

workflow_read_help() {
  cat <<EOF

  ./$(basename "$0") workflow read --org <ORG_NAME> --workflow-group <WF_GROUP_NAME> --workflow-id <WORKFLOW_ID>

EOF
}

workflow_list_all_help() {
  cat <<EOF

  ./$(basename "$0") workflow list_all --org <ORG_NAME> --workflow-group <WF_GROUP_NAME>

EOF
}

create_stack() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group are required"
    stack_create_help
    exit 1
  fi
  runOnCreate=${run_on_create:-false}
  url="$api_url/orgs/$org_id/wfgrps/$wfgrp_id/stacks/?runOnCreate=$runOnCreate"
  response=$(curl -s --http1.1 -X POST \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    --data-raw "${payload}" "$url")
  if [ $? -eq 0 ] && echo "$response" | grep -q -E "Stack.*created"; then
    echo "$response" | jq
  else
    echo "== Stack creation failed =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
}

# Create Delete Stack function
delete_stack() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ] || [ -z "${stack_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group, --stack-id are required"
    stack_delete_help
    exit 1
  fi
  url="$api_url/orgs/$org_id/wfgrps/$wfgrp_id/stacks/$stack_id"
  response=$(curl -s --http1.1 -X DELETE \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -eq 0 ] && echo "$response" | grep -q -E "Stack.*deleted"; then
    echo "$response"
  else
    echo "== Stack is not deleted =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
}

get_stack() {
  url="$api_url/orgs/$org_id/wfgrps/$wfgrp_id/stacks/$stack_id"
  response=$(curl -s --http1.1 -X GET \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
    echo "== Retrieving Stack failed =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
  echo "$response"
}
# return JSON for get_stack_status()
get_stack_status() {
  response=$(get_stack)
  if echo "$response" | grep -q '"msg":' && echo "$response" | grep -q '"LatestWfStatus":'; then
    echo "$response" | jq -r '.msg.LatestWfStatus'
  else
    echo false
  fi
}

get_stackrun_status() {
  response=$(get_wfruns_in_stackrun)
  if echo "$response" | grep -q '"LatestStatus":'; then
    echo "$response" | jq -r '.msg.LatestStatus'
  else
    echo false
  fi
}

get_wfruns_in_stackrun() {
  url="$api_url/orgs/$org_id/wfgrps/$wfgrp_id/stacks/${stack_id}${stack_run_id}"
  response=$(curl -s --http1.1 -X GET \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
    echo "== Retrieving Workflow Run from StackRun failed =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
  echo "$response"
}

# create_workflow_in_stack() {
#     url="$api_url/orgs/${org_id}/wfgrps/{wfgrp_id}/stacks/{stack_id}/wfs/"
#     response=$(curl -s --http1.1 -X POST \
#       -H 'PrincipalId: ""' \
#       -H "Authorization: apikey $api_token" \
#       -H "Content-Type: application/json" \
#       --data-raw "${payload}" "$url")
#     if [ $? -eq 0 ] && echo "$response" | grep -q "\"data\""; then
#       echo "$response" | jq
#     else
#       echo "== Workflow creation failed =="
#       echo "url: $url"
#       echo "response: $response"
#       exit 1
#     fi
# }

# list_all_workflows_inside_stack() {
#     url="$api_url/orgs/${org_id}/wfgrps/{wfgrp_id}/stacks/{stack_id}/wfs/listall/"
#     response=$(curl -s --http1.1 -X GET \
#       -H 'PrincipalId: ""' \
#       -H "Authorization: apikey $api_token" \
#       -H "Content-Type: application/json" \
#       "$url")
#     if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
#         echo "== Listing all workflows failed =="
#         echo "url: $url"
#         echo "response: $response"
#         exit 1
#     fi
#     echo "$response"
# }

# read_workflow_in_stack() {
#     url="$api_url/orgs/${org_id}/wfgrps/{wfgrp_id}/stacks/{stack_id}/wfs/${wf_id}"
#     response=$(curl -s --http1.1 -X GET \
#       -H 'PrincipalId: ""' \
#       -H "Authorization: apikey $api_token" \
#       -H "Content-Type: application/json" \
#       "$url")
#     if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
#         echo "== Reading worklfow failed  =="
#         echo "url: $url"
#         echo "response: $response"
#         exit 1
#     fi
#     echo "$response"
# }

# delete_workflow_in_stack() {
#     url="$api_url/orgs/${org_id}/wfgrps/{wfgrp_id}/stacks/{stack_id}/wfs/${wf_id}"
#     response=$(curl -s --http1.1 -X DELETE \
#       -H 'PrincipalId: ""' \
#       -H "Authorization: apikey $api_token" \
#       -H "Content-Type: application/json" \
#       "$url")
#     if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
#         echo "== Deleting worklfow failed  =="
#         echo "url: $url"
#         echo "response: $response"
#         exit 1
#     fi
#     echo "$response"
# }

# listall_artifacts_in_stack() {
#     url="$api_url/orgs/${org_id}/wfgrps/{wfgrp_id}/stacks/{stack_id}/wfs/${wf_id}/listall_artifacts"
#     response=$(curl -s --http1.1 -X GET \
#       -H 'PrincipalId: ""' \
#       -H "Authorization: apikey $api_token" \
#       -H "Content-Type: application/json" \
#       "$url")
#     if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
#         echo "== Listing all Artifacts from worklfow failed  =="
#         echo "url: $url"
#         echo "response: $response"
#         exit 1
#     fi
#     echo "$response"
# }

# get_workflow_outputs_in_stack() {
#     url="$api_url/orgs/${org_id}/wfgrps/{wfgrp_id}/stacks/{stack_id}/wfs/${wf_id}/outputs"
#     response=$(curl -s --http1.1 -X GET \
#       -H 'PrincipalId: ""' \
#       -H "Authorization: apikey $api_token" \
#       -H "Content-Type: application/json" \
#       "$url")
#     if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
#         echo "== Listing outputs from worklfow failed  =="
#         echo "url: $url"
#         echo "response: $response"
#         exit 1
#     fi
#     echo "$response"
# }

create_workflow() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group are required"
    workflow_create_help
    exit 1
  fi
  url="$api_url/orgs/${org_id}/wfgrps/${wfgrp_id}/wfs/"
  response=$(curl -s --http1.1 -X POST \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    --data-raw "${payload}" "$url")
  if [ $? -eq 0 ] && echo "$response" | grep -q -E "Workflow.*created"; then
    echo "$response" | jq
  else
    echo "== Workflow creation failed =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
}

list_all_workflow() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group are required"
    workflow_list_all_help
    exit 1
  fi
  url="$api_url/orgs/${org_id}/wfgrps/${wfgrp_id}/wfs/listall/"
  response=$(curl -s --http1.1 -X GET \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
    echo "== Listing all workflows failed =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
  echo "$response"
}

read_workflow() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ] || [ -z "${wf_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group, --workflow-id are required"
    workflow_read_help
    exit 1
  fi
  url="$api_url/orgs/${org_id}/wfgrps/${wfgrp_id}/wfs/${wf_id}"
  response=$(curl -s --http1.1 -X GET \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
    echo "== Reading worklfow failed  =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
  echo "$response"
}

delete_workflow() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ] || [ -z "${wf_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group, --worklfow-id are required"
    workflow_delete_help
    exit 1
  fi
  url="$api_url/orgs/${org_id}/wfgrps/${wfgrp_id}/wfs/${wf_id}"
  response=$(curl -s --http1.1 -X DELETE \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] && echo "$response" | grep -q -E "Workflow.*created"; then
    echo "${response}"
  else
    echo "== Deleting worklfow failed  =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
}

list_all_artifacts() {
  if [ -z "${org_id}" ] || [ -z "${wfgrp_id}" ] || [ -z "${wf_id}" ]; then
    echo
    echo "ERROR: parameters --org, --workflow-group, --worklfow-id are required"
    artifacts_list_all_help
    exit 1
  fi
  url="$api_url/orgs/${org_id}/wfgrps/${wfgrp_id}/wfs/${wf_id}/listall_artifacts"
  response=$(curl -s --http1.1 -X GET \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
    echo "== Listing all Artifacts from worklfow failed  =="
    echo "url: $url"
    echo "response: $response"
    exit 1
  fi
  echo "$response"
}

get_workflow_outputs() {
  url="$api_url/orgs/${org_id}/wfgrps/${wfgrp_id}/wfs/${wf_id}/outputs"
  response=$(curl -s --http1.1 -X GET \
    -H 'PrincipalId: ""' \
    -H "Authorization: apikey $api_token" \
    -H "Content-Type: application/json" \
    "$url")
  if [ $? -ne 0 ] || echo "$response" | grep -q "\"error\""; then
      echo "== Listing outputs from worklfow failed  =="
      echo "url: $url"
      echo "response: $response"
      exit 1
  fi
  echo "$response"
}

create_stack_parse_response() {
  if [ "$response" != "" ]; then
    stack_id=${stack_id:-$(echo "$response" | jq -r '.data.stack.ResourceName')}
    stack_run_id=$(echo "$response" | jq -r '.data.stack.StackRunId')
    echo "$dashboard_url/orgs/$org_id/wfgrps/$wfgrp_id/stacks/$stack_id"
  else
    exit 1
  fi

  # check stackrun status
  if [ "$wait_execution" = "true" ] && [ "$run_on_create" = "true" ]; then
    echo "Stack run executed"
    while [ "$(get_stackrun_status)" != "ERRORED" ] \
      && [ "$(get_stackrun_status)" != "COMPLETED" ] \
      && [ "$(get_stackrun_status)" != "APPROVAL_REQUIRED" ]; do
      echo "Stack under deployment..."
      sleep 5
    done
  fi

  # print final stack status
  if [ "$wait_execution" = "true" ] && [ "$run_on_create" = "true" ]; then
    echo "Stack finished with $(get_stack_status) status"
    exit 0
  else
    echo "Stack created. To run it go to the Dashboard!"
    exit 0
  fi
}

delete_stack_parse_response() {
  echo "${response}" | jq
  exit 0
}

create_workflow_parse_response() {
  if [ "$response" != "" ]; then
    wf_id=${wf_id:-$(echo "$response" | jq -r '.data.ResourceName')}
    # stack_run_id=$(echo "$response" | jq -r '.data.stack.StackRunId')
    echo "$dashboard_url/orgs/$org_id/wfgrps/$wfgrp_id/wfs/$wf_id"
    echo "Workflow created. To run it go to the Dashboard!"
    exit 0
  else
    exit 1
  fi

  # check stackrun status
  # if [ "$wait_execution" = "true" ] && [ "$run_on_create" = "true" ]; then
  #   echo "Workflow run executed"
  #   while [ "$(get_workflow_outputs)" != "ERRORED" ] \
  #       && [ "$(get_workflow_outputs)" != "COMPLETED" ] \
  #       && [ "$(get_workflow_outputs)" != "APPROVAL_REQUIRED" ]; do
  #       echo "Workflow under deployment..."
  #       sleep 5
  #   done
  # fi

  # print final stack status
  # if [ "$wait_execution" = "true" ] && [ "$run_on_create" = "true" ]; then
  #   get_workflow_outputs
  #   # echo "Workflow finished with $(get_workflow_status) status"
  #   exit 0
  # else
  #   echo "Workflow created. To run it go to the Dashboard!"
  #   exit 0
  # fi
}

list_all_workflow_parse_response() {
  if [ "$response" != "" ]; then
    printf ">> List of wrofklows\n * group: %s\n * organization: %s\n\n" "${wfgrp_id}" "${org_id}"
    mkfifo response_pipe
    echo "${response}" | jq -r ' .msg[] | {wf_id: .ResourceName, desc: .Description} | [.wf_id, .desc] | @tsv' > response_pipe &
    while read line; do
      wf_id=$(echo "${line}" | cut -f1)
      wf_desc=$(echo "${line}" | awk '{if ( NF > 1 ) print}' | cut -f2)
      printf "> Workflow Name: %s\n  Description: %s\n\n" "${wf_id}" "${wf_desc:="-"}"
    done < response_pipe
    rm response_pipe
    exit 0
  else
      exit 1
  fi
}

read_workflow_parse_response() {
  echo "${response}" | jq
  exit 0
}

delete_workflow_parse_response() {
  echo "${response}" | jq
  exit 0
}

list_all_artifacts_parse_response() {
 echo "${response}" | jq
 exit 0
}

integrate_aws_parse_response() {
  echo "${response}" | jq
  exit 0
}

integrate_aws(){
  if [ -z "${payload}" ]; then
    echo
    echo "ERROR: payload must be provided"
    aws_integrate_help
    exit 1
  fi
  array_length="$(echo "${payload}" | jq '.[] | length')"
  i=0
  while [ ${i} -lt ${array_length} ]; do
    object_payload=$(echo "${payload}" | jq ".[][$i]")
    url="$api_url/orgs/${org_id}/integrations"
    response=$(curl -s --http1.1 -X POST \
      -H 'PrincipalId: ""' \
      -H "Authorization: apikey $api_token" \
      -H "Content-Type: application/json" \
      --data-raw "${object_payload}" "$url")
    if [ $? -eq 0 ] && echo "$response" | grep -q "\"data\""; then
      echo "$response" | jq
    else
      echo "== Integration creation failed =="
      echo "url: $url"
      echo "response: $response"
      exit 1
    fi
    i=$(( $i + 1 ))
  done
}

# main function
main() {
  org_id=$org
  wfgrp_id="$workflow_group"

  if [ -n "$stack_id" ] && [ -z "$json_patch" ]; then
    payload=$(echo "${payload}" | jq ".ResourceName = \"$stack_id\"")
  elif [ -n "$wf_id" ] && [ -z "$json_patch" ]; then
    payload=$(echo "${payload}" | jq ".ResourceName = \"$wf_id\"")
  elif [ -n "$json_patch" ]; then
    patch_payload "$(get_root_patch_keys)"
  fi
  if [ "${dry_run}" = "true" ]; then
    echo "${payload}" | jq
    exit 0
  elif [ "${preview_patch}" = "true" ]; then
    echo "${payload}" | jq
  fi

  response=$("${service_option}"_"${service}")

  if [ $? -ne 0 ]; then
    echo "$response"
    exit 1
  elif [ "${output_json}" ] && [ "${service_option}" != delete ] && [ "${service_option}" != read ]; then
    echo "$response"
  fi

  "${service_option}"_"${service}"_parse_response
}

check_patch_subkey() {
  if echo "${json_patch}" | jq -r "$1 | keys_unsorted[]"; then
    return 0
  fi
  return 1
}

get_root_patch_keys()  {
  echo "${json_patch}" | jq -r "keys_unsorted[]"
}

get_sub_patch_keys() {
  echo "${json_patch}" | jq -r "$1 | keys_unsorted[]"
}

is_sub_patch_key_array() {
  echo "${json_patch}" | jq -r "$1 | if type==\"array\" then \"yes\" else \"no\" end"
}

fetch_patch_array_length() {
  echo "${json_patch}" | jq "$1 | length"
}

patch_payload_array() {
  array_length=$(($(fetch_patch_array_length "$1")-1))
  if [ "${array_length}" -lt 0 ]; then
    payload="$(echo "${payload}" | jq "${1} = []")"
    return 0
  fi
  until [ $array_length -lt 0 ]; do
    patch_payload "$(get_sub_patch_keys "${1}[${array_length}]")" "${1}[${array_length}]"
    array_length=$((array_length-1))
  done
}

patch_payload() {
  root_keys="$1"
  for key in ${root_keys}; do
    if check_patch_subkey "${2}.${key}" >/dev/null 2>&1; then
      if [ "$(is_sub_patch_key_array "${2}.${key}")" = "yes" ]; then
        patch_payload_array "${2}.${key}"
      else
        patch_payload "$(get_sub_patch_keys "${2}.${key}")" "${2}.${key}"
      fi
    else
      payload="$(echo "${payload}" | jq "${2}.${key} = \"$(echo "${json_patch}" | jq -r "${2}.${key}")\"")"
    fi
  done
}

if [ -z "$api_token" ] || [ "sgu_" != "${api_token:0:4}" ]; then
    echo "Invalid or no API Token provided. Expecting it in \"SG_API_TOKEN\" environment variable. Navigate to StackGuardian platform to get your api token: $dashboard_url/orgs/$org/settings?tab=api_key"
    exit 1
fi

case "$1" in
  stack)
    service="$1"
    case "$2" in
      create|delete)
        service_option="$2"
        shift 2
        ;;
      help)
        stack_help
        exit 0
        ;;
      *)
        echo
        echo "ERROR: unknown option $2" >&2
        stack_help
        exit 1
    esac
    ;;
  workflow)
    service="$1"
    case "$2" in
      create|delete|read|list_all)
        service_option="$2"
        shift 2
        ;;
      help)
        workflow_help
        exit 0
        ;;
      *)
        echo
        echo "ERROR: unknown option $2" >&2
        workflow_help
        exit 1
    esac
    ;;
  artifacts)
    service="$1"
    case "$2" in
      list_all)
        service_option="$2"
        shift 2
        ;;
      help)
        artifacts_help
        exit 0
        ;;
      *)
        echo
        echo "ERROR: unknown option $2" >&2
        artifacts_help
        exit 1
    esac
    ;;
  aws)
    service="$1"
    case "$2" in
      integrate)
        service_option="$2"
        shift 2
        ;;
      help)
        aws_help
        exit 0
        ;;
      *)
        echo
        echo "ERROR: unknown option $2" >&2
        aws_help
        exit 1
    esac
    ;;
  help)
    help
    exit 0
    ;;
  *)
    echo
    echo "ERROR: unknown service $1" >&2
    help
    exit 1
    ;;
esac

# if [ $# -lt 2 ]; then
#   "${service}"_"${service_option}"_help
#   exit 1
# fi

# Parse command-line arguments
while [ $# -gt 0 ]; do
  case "$1" in
    --org)
      readonly org="$2"
      shift 2
      ;;
    --workflow-group)
      readonly workflow_group="$2"
      shift 2
      ;;
    --stack-id)
      stack_id="$2"
      shift 2
      ;;
    --workflow-id)
      wf_id="$2"
      shift 2
      ;;
    --wait)
      readonly wait_execution=true
      shift
      ;;
    --run)
      readonly run_on_create=true
      shift
      ;;
    --patch-payload)
      readonly json_patch="$2"
      shift 2
      ;;
    --preview)
      readonly preview_patch=true
      shift
      ;;
    --output-json)
      readonly output_json=true
      shift
      ;;
    --dry-run)
      readonly dry_run=true
      shift
      ;;
    --)
      shift
      if [ $# -gt 1 ]; then
        echo
        echo "ERROR: only file name should be provided after --"
        exit 1
      fi
      if [ -e "$1" ]; then
        payload="$(cat "$1")"
      else
        echo
        echo "ERROR: file $1 not found or does not exist"
      fi
      break
      ;;
    help)
      "${service}"_"${service_option}"_help
      exit 0
      ;;
    *)
      echo
      echo "ERROR: unknown option $1" >&2
      "${service}"_"${service_option}"_help
      exit 1
      ;;
  esac
done

main "$@"
